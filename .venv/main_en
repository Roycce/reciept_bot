import os
import logging
import json
import asyncio
import uuid
from datetime import datetime
from typing import Dict
from aiogram import Bot, Dispatcher, types, exceptions
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)
from dotenv import load_dotenv
from gspread_asyncio import AsyncioGspreadClientManager
from oauth2client.service_account import ServiceAccountCredentials


# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
API_TOKEN = os.getenv("BOT_API_TOKEN")
ADMIN_IDS = list(map(int, os.getenv("ADMIN_IDS", "").split(","))) if os.getenv("ADMIN_IDS") else []

# Constants
DATA_FILE = "users.json"
SHEET_URL = os.getenv("SHEET_URL")
WORKSHEET_NAME = os.getenv("WORKSHEET_NAME")

# Initialize bot and dispatcher
bot = Bot(token=API_TOKEN)
dp = Dispatcher(storage=MemoryStorage())

# Temporary storage and lock
temp_storage: Dict[str, dict] = {}
temp_storage_lock = asyncio.Lock()


class CheckForm(StatesGroup):
    username = State()
    date = State()
    cash = State()
    noncash = State()
    fullname = State()


class GoogleSheetsManager:
    def __init__(self):
        self.client_manager = AsyncioGspreadClientManager(
            lambda: ServiceAccountCredentials.from_json_keyfile_name(
                "credentials.json",
                [
                    "https://www.googleapis.com/auth/spreadsheets",
                    "https://www.googleapis.com/auth/drive",
                ],
            )
        )

    async def append_data(self, data: dict, status: str) -> bool:
        try:
            client = await self.client_manager.authorize()
            spreadsheet = await client.open_by_url(SHEET_URL)
            worksheet = await spreadsheet.worksheet(WORKSHEET_NAME)

            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºÑƒ Ğ¸Ğ· Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            users = load_users()
            user_note = users.get(data["username"], {}).get("note", "")

            # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ñ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºĞ¾Ğ¹ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¼ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğµ
            row = [
                data["check_id"],
                data["username"],
                data["date"],
                data["cash"],
                data["noncash"],
                data["fullname"],
                status,
                user_note  # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºÑƒ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ†
            ]

            await worksheet.append_row(row)
            return True
        except Exception as e:
            logger.error(f"Google Sheets Error: {str(e)}", exc_info=True)
            return False


gsheets = GoogleSheetsManager()


def load_users() -> dict:
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_users(users: dict):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(users, f, indent=4, ensure_ascii=False)


def get_user_id(username: str) -> int | None:
    users = load_users()
    user_data = users.get(username.lower())
    return user_data["user_id"] if user_data else None


def get_cancel_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="âŒ Cancel")]],
        resize_keyboard=True,
    )


def get_date_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="ğŸ“… Today"), KeyboardButton(text="ğŸ“ Enter date")],
            [KeyboardButton(text="âŒ Cancel")]
        ],
        resize_keyboard=True,
    )


@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    users = load_users()
    username = message.from_user.username or f"ID_{message.from_user.id}"
    user_id = message.from_user.id

    if username:
        # If the user already exists, update their data
        if username.lower() in users:
            users[username.lower()]["user_id"] = user_id
        else:
            # If the user is new, add them with an empty note
            users[username.lower()] = {"user_id": user_id, "note": ""}
        save_users(users)

    if user_id not in ADMIN_IDS:
        for admin_id in ADMIN_IDS:
            try:
                await bot.send_message(
                    admin_id,
                    f"ğŸ‘¤ New user: @{username if username != f'ID_{message.from_user.id}' else 'Not specified'} (ID: {user_id})"
                )
            except Exception as e:
                logger.error(f"Admin notification error: {e}")

    await message.answer(
        "ğŸŒŸ Welcome to the receipt management bot!\n"
        "Use /check to create a new receipt.",
        reply_markup=get_cancel_keyboard(),
    )


@dp.message(Command("add_user"))
async def cmd_add_user(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        return await message.answer("ğŸš« This command is only available to administrators.")

    args = message.text.split(maxsplit=3)
    if len(args) < 3:
        return await message.answer("âŒ Usage: /add_user <username> <user_id> [note]")

    username, user_id = args[1].lower(), args[2]
    note = args[3] if len(args) > 3 else ""

    if not user_id.isdigit():
        return await message.answer("âŒ user_id must be a number!")

    users = load_users()
    users[username] = {"user_id": int(user_id), "note": note}

    save_users(users)

    await message.answer(f"âœ… User @{username} (ID: {user_id}) added! Note: {note}")


@dp.message(Command("list_users"))
async def cmd_list_users(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        return await message.answer("ğŸš« This command is only available to administrators.")

    users = load_users()
    if not users:
        return await message.answer("ğŸ“‚ The user list is empty.")

    user_list = "\n".join([f"@{username} -> {user_data['user_id']} | Note: {user_data.get('note', 'No note')}"
                           for username, user_data in users.items()])
    await message.answer(f"ğŸ“‹ User list:\n{user_list}")


@dp.message(Command("set_note"))
async def cmd_set_note(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        return await message.answer("ğŸš« This command is only available to administrators.")

    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        return await message.answer("âŒ Usage: /set_note <username> <note>")

    username, note = args[1].lower(), args[2]

    users = load_users()
    if username not in users:
        return await message.answer(f"âŒ User @{username} not found!")

    users[username]['note'] = note
    save_users(users)

    await message.answer(f"âœ… Note for @{username} updated successfully!")


@dp.message(Command("check"))
async def cmd_check(message: types.Message, state: FSMContext):
    if message.from_user.id not in ADMIN_IDS:
        return await message.answer("ğŸš« This command is only available to administrators.")

    await state.set_state(CheckForm.username)
    await message.answer(
        "ğŸ‘¤ Enter the recipient's username *without @*, note, or user ID:",
        parse_mode="Markdown",
        reply_markup=get_cancel_keyboard(),
    )


@dp.message(CheckForm.username)
async def process_username(message: types.Message, state: FSMContext):
    if message.text == "âŒ Cancel":
        await state.clear()
        return await message.answer("âŒ Receipt creation canceled.", reply_markup=types.ReplyKeyboardRemove())

    users = load_users()
    input_data = message.text.strip().lower()

    # Search by username
    if input_data in users:
        username = input_data
        await message.answer(f"âœ… User found by username: @{username}")
    else:
        # Search by user_id
        user_by_id = next((username for username, data in users.items() if str(data["user_id"]) == input_data), None)
        if user_by_id:
            username = user_by_id
            await message.answer(f"âœ… User found by user_id: @{username}")
        else:
            # Search by note
            user_by_note = next((username for username, data in users.items() if input_data in data.get("note", "").lower()), None)
            if user_by_note:
                username = user_by_note
                await message.answer(f"âœ… User found by note: @{username}")
            else:
                return await message.answer("âŒ User not found! Check the entered data.")

    await state.update_data(username=username)
    await state.set_state(CheckForm.date)
    await message.answer(
        "ğŸ“… Choose the receipt date:",
        reply_markup=get_date_keyboard(),
    )


@dp.message(CheckForm.date)
async def process_date(message: types.Message, state: FSMContext):
    if message.text == "âŒ Cancel":
        await state.clear()
        return await message.answer("âŒ Receipt creation canceled.", reply_markup=types.ReplyKeyboardRemove())

    if message.text == "ğŸ“… Today":
        date = datetime.now().strftime("%d.%m.%Y")
    else:
        try:
            datetime.strptime(message.text, "%d.%m.%Y")
            date = message.text
        except ValueError:
            await message.answer("âŒ Invalid format! Use DD.MM.YYYY")
            await state.set_state(CheckForm.date)  # ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ´Ğ°Ñ‚Ñƒ
            return

    await state.update_data(date=date)
    await state.set_state(CheckForm.cash)
    await message.answer(
        "ğŸ’° Enter cash:",
        reply_markup=get_cancel_keyboard(),
    )


@dp.message(CheckForm.cash)
async def process_cash(message: types.Message, state: FSMContext):
    if message.text == "âŒ Cancel":
        await state.clear()
        return await message.answer("âŒ Receipt creation canceled.", reply_markup=types.ReplyKeyboardRemove())

    if not message.text.isdigit():
        return await message.answer("âŒ Cash must be a number!")

    await state.update_data(cash=message.text)
    await state.set_state(CheckForm.noncash)
    await message.answer(
        "ğŸ’° Enter Non cash:",
        reply_markup=get_cancel_keyboard(),
    )


@dp.message(CheckForm.noncash)
async def process_noncash(message: types.Message, state: FSMContext):
    if message.text == "âŒ Cancel":
        await state.clear()
        return await message.answer("âŒ Receipt creation canceled.", reply_markup=types.ReplyKeyboardRemove())

    if not message.text.isdigit():
        return await message.answer("âŒ Cash must be a number!")

    await state.update_data(noncash=message.text)

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ
    data = await state.get_data()
    username = data.get("username")
    users = load_users()
    user_note = users.get(username, {}).get("note", "")

    # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºĞ°, Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ ĞµÑ‘ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ
    if user_note:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=f"âœ… Use note: {user_note}", callback_data="use_note")],
            [InlineKeyboardButton(text="ğŸ“ Enter manually", callback_data="enter_manually")]
        ])
        await message.answer(
            f"ğŸ“› We found a note for this user: {user_note}\n"
            "Do you want to use it as the full name?",
            reply_markup=keyboard,
        )
    else:
        # Ğ•ÑĞ»Ğ¸ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºĞ¸ Ğ½ĞµÑ‚, Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ²Ğ²Ğ¾Ğ´Ñƒ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸
        await state.set_state(CheckForm.fullname)
        await message.answer(
            "ğŸ“› Enter the recipient's full name:",
            reply_markup=get_cancel_keyboard(),
        )


# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° inline-ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº
@dp.callback_query(lambda c: c.data in ["use_note", "enter_manually"])
async def handle_fullname_choice(callback_query: types.CallbackQuery, state: FSMContext):
    if callback_query.data == "use_note":
        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºÑƒ ĞºĞ°Ğº Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ
        data = await state.get_data()
        username = data.get("username")
        users = load_users()
        user_note = users.get(username, {}).get("note", "")

        await state.update_data(fullname=user_note)
        await callback_query.message.edit_text(f"âœ… Full name set to: {user_note}")

        # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ ÑˆĞ°Ğ³Ñƒ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ñƒ Ñ‡ĞµĞºĞ°)
        await preview_check(callback_query.message, state)
    else:
        # Ğ—Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ²Ğ²Ğ¾Ğ´ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ
        await callback_query.message.edit_text("ğŸ“› Enter the recipient's full name:")
        await state.set_state(CheckForm.fullname)


@dp.message(CheckForm.fullname)
async def process_fullname(message: types.Message, state: FSMContext):
    if message.text == "âŒ Cancel":
        await state.clear()
        return await message.answer("âŒ Receipt creation canceled.", reply_markup=types.ReplyKeyboardRemove())

    await state.update_data(fullname=message.text)
    data = await state.get_data()

    # ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ñƒ Ñ‡ĞµĞºĞ°
    await preview_check(message, state)


async def preview_check(message: types.Message, state: FSMContext):
    data = await state.get_data()

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºÑƒ Ğ¸Ğ· Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    users = load_users()
    user_note = users.get(data["username"], {}).get("note", "")

    check_preview = (
        f"ğŸ“‹ <b>Receipt Preview</b>\n"
        f"ğŸ‘¤: @{data.get('username', 'Unknown')}\n"
        f"ğŸ“… Date: {data.get('date', 'Unknown')}\n"
        f"ğŸ’° Cash: {data.get('cash', '0')}\n"
        f"ğŸ’° Non cash: {data.get('noncash', '0')}\n"
        f"ğŸ“› Full Name: {data.get('fullname', 'Unknown')}\n"
        f"ğŸ“ Note: {user_note if user_note else 'No note'}"  # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºÑƒ Ğ² Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€
    )

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœ… Send", callback_data="send_check"),
         InlineKeyboardButton(text="ğŸ”„ Redo", callback_data="redo_check")]
    ])
    await message.answer(check_preview, reply_markup=keyboard, parse_mode="HTML")

@dp.callback_query(lambda c: c.data == "redo_check")
async def redo_check(callback_query: types.CallbackQuery, state: FSMContext):
    try:
        # Clear the state to restart the process
        await state.clear()

        # Edit the message to remove the inline keyboard
        await callback_query.message.edit_text(
            "âŒ Check creation canceled. Starting over!",
            reply_markup=None  # Remove the inline keyboard
        )

        # Send a new message with instructions
        await callback_query.message.answer(
            "ğŸ‘¤ Enter the username *without @*, a note, or the user ID of the recipient:",
            parse_mode="Markdown",
            reply_markup=get_cancel_keyboard()  # Use a different keyboard
        )
    except Exception as e:
        logging.error(f"Error in redo_check: {e}")

@dp.callback_query(lambda c: c.data == "send_check")
async def send_check(callback_query: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    user_id = get_user_id(data["username"])

    if not user_id:
        await callback_query.message.edit_text(f"âŒ User @{data['username']} not found!")
        return

    # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ID Ñ‡ĞµĞºĞ°
    check_id = str(uuid.uuid4())
    data["check_id"] = check_id

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Google Sheets Ñ Ğ·Ğ°Ğ¼ĞµÑ‚ĞºĞ¾Ğ¹
    try:
        success = await gsheets.append_data(data, "Pending")
        if not success:
            raise Exception("Error adding to Google Sheets")
    except Exception as e:
        logger.error(f"Google Sheets write error: {str(e)}")
        await callback_query.message.edit_text("âŒ Error saving receipt!")
        return

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ‡ĞµĞºĞ° Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ
    async with temp_storage_lock:
        temp_storage[check_id] = data

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(
            text="âœ” Confirm",
            callback_data=f"confirm_check:{user_id}:{check_id}"
        )],
        [InlineKeyboardButton(
            text="âœ– Reject",
            callback_data=f"reject_check:{user_id}:{check_id}"
        )]
    ])

    try:
        await bot.send_message(
            user_id,
            f"ğŸ”” A receipt has been sent to you for confirmation:\n"
            f"ğŸ“… Date: {data['date']}\n"
            f"ğŸ’° Cash: {data['cash']}\n"
            f"ğŸ’° Non cash: {data['noncash']}\n"
            f"ğŸ“› Full Name: {data['fullname']}\n"
            f"Status: Pending â³",
            reply_markup=keyboard
        )
        await callback_query.message.edit_text("âœ… Receipt successfully sent to the user!")
        await state.clear()
    except exceptions.TelegramBadRequest as e:
        logger.error(f"Send error: {e}")
        await callback_query.message.edit_text("âŒ User not found or chat unavailable!")
    except Exception as e:
        logger.error(f"Receipt send error: {str(e)}")
        await callback_query.message.edit_text("âŒ Error sending receipt!")


async def update_status_in_sheets(check_data: dict, new_status: str):
    try:
        client = await gsheets.client_manager.authorize()
        spreadsheet = await client.open_by_url(SHEET_URL)
        worksheet = await spreadsheet.worksheet(WORKSHEET_NAME)

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ¸ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸
        rows = await worksheet.get_all_values()
        headers = rows[0]  # ĞŸĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° â€” Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸

        # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¸Ğ½Ğ´ĞµĞºÑ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ° "Status" (Ğ¸Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾, Ğ³Ğ´Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ ÑÑ‚Ğ°Ñ‚ÑƒÑ)
        status_column_index = headers.index("Status") if "Status" in headers else -1

        if status_column_index == -1:
            logger.error("Column 'Status' not found in the sheet!")
            return False

        # Ğ˜Ñ‰ĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ñ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğ¼ check_id
        for i, row in enumerate(rows[1:], start=2):  # ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸
            if row and row[0] == check_data["check_id"]:
                # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ² Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ¼ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğµ
                await worksheet.update_cell(i, status_column_index + 1, new_status)
                return True

        logger.error(f"Row with check_id {check_data['check_id']} not found!")
        return False
    except Exception as e:
        logger.error(f"Google Sheets status update error: {str(e)}")
        return False


@dp.callback_query(lambda c: c.data.startswith("confirm_check:"))
async def confirm_check(callback_query: types.CallbackQuery):
    parts = callback_query.data.split(":")
    user_id = int(parts[1])
    check_id = parts[2]

    async with temp_storage_lock:
        check_data = temp_storage.get(check_id)

    if not check_data:
        return await callback_query.message.answer("âŒ Receipt expired or not found!")

    success = await update_status_in_sheets(check_data, "Accepted âœ…")

    for admin_id in ADMIN_IDS:
        try:
            await bot.send_message(
                admin_id,
                f"ğŸ“Š Receipt from @{check_data['username']} ({check_data['date']})\n"
                f"Amounts: {check_data['cash']}/{check_data['noncash']}\n"
                f"Full Name: {check_data['fullname']}\n"
                f"Status: {'Accepted âœ…' if success else 'Error âŒ'}"
            )
        except Exception as e:
            logger.error(f"Admin send error: {str(e)}")

    await callback_query.message.edit_reply_markup(reply_markup=None)

    if success:
        await callback_query.message.answer("âœ… Receipt confirmed!")  # Send new message
    else:
        await callback_query.message.answer("âŒ Error updating status!")


@dp.callback_query(lambda c: c.data.startswith("reject_check:"))
async def reject_check(callback_query: types.CallbackQuery):
    parts = callback_query.data.split(":")
    user_id = int(parts[1])
    check_id = parts[2]

    async with temp_storage_lock:
        check_data = temp_storage.get(check_id)

    if not check_data:
        return await callback_query.message.answer("âŒ Receipt expired or not found!")

    success = await update_status_in_sheets(check_data, "Rejected âŒ")

    for admin_id in ADMIN_IDS:
        try:
            await bot.send_message(
                admin_id,
                f"ğŸ“Š Receipt from @{check_data['username']} ({check_data['date']})\n"
                f"Amounts: {check_data['cash']}/{check_data['noncash']}\n"
                f"Full Name: {check_data['fullname']}\n"
                f"Status: {'Rejected âŒ' if success else 'Error âŒ'}"
            )
        except Exception as e:
            logger.error(f"Admin send error: {str(e)}")

    await callback_query.message.edit_reply_markup(reply_markup=None)

    if success:
        await callback_query.message.answer("âŒ Receipt rejected!")  # Send new message
    else:
        await callback_query.message.answer("âŒ Error updating status!")


async def main():
    logger.info("Starting bot...")
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
